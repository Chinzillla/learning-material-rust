# Turing Machines

Task: Discuss the role of Turing machines in the evolution of algorithmic thinking. Write a simple Turing machine simulation in Rust, and explain how it helps in understanding the limits of computation and algorithm design.

### 1. Why Turing Machines Matter

* **Formalizing “algorithm.”** In 1936, Alan Turing gave us an abstract “machine” with a finite control (the head), an infinite tape for memory, and a tiny set of rules. This simple model exactly captured what we intuitively mean by an “effective procedure” or algorithm.
* **Church–Turing thesis.** By showing that his machine could simulate any other reasonable “mechanical” computation, Turing—and independently Alonzo Church—hypothesized that anything computable by any physical device is computable by a Turing machine.
* **Decidability and the halting problem.** Turing used his machines to prove there’s no general algorithm to decide whether an arbitrary program will halt—laying the groundwork for undecidability and showing concrete limits to what computers can do.
* **Complexity foundations.** Later, when people started counting how many steps a Turing machine takes, they effectively invented time‐complexity. “Big‐O” traces its roots back to reasoning about how many moves a TM needs.
* **Programming languages & compilers.** Every real programming language can be thought of as one particular “high‐level” encoding of Turing-machine instructions. Understanding the TM model informs compiler design, optimization, and even proofs of correctness.

---

### 2. A Simple Turing Machine in Rust

Below is a minimal “unary incrementer” TM. It takes a tape consisting of a run of `1`s (e.g. `111`), moves right until the first blank, writes one more `1` (so `111` → `1111`), and halts.

```rust
use std::collections::HashMap;

// What symbol on the tape?
type Symbol = char;  // '1' or '_'

// Which direction to move the head?
#[derive(Clone, Copy)]
enum Direction { Left, Right, Stay }

// Labels for our states:
#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]
enum State { Start, MoveRight, WriteOne, Halt }

// A single transition: (new_state, write_symbol, move_dir)
type Action = (State, Symbol, Direction);

// The TM itself:
struct TuringMachine {
    tape:  HashMap<isize, Symbol>,      // infinite tape
    head:  isize,                       // current head position
    state: State,                       // current state
    table: HashMap<(State, Symbol), Action>,
}

impl TuringMachine {
    fn new(input: &str) -> Self {
        // Initialize tape with input
        let mut tape = HashMap::new();
        for (i, ch) in input.chars().enumerate() {
            tape.insert(i as isize, ch);
        }
        // blank elsewhere implicitly '_'
        let mut table = HashMap::new();
        // State Start: jump to MoveRight
        table.insert((State::Start, '1'), (State::MoveRight, '1', Direction::Right));
        table.insert((State::Start, '_'),     (State::WriteOne, '_', Direction::Stay));
        // MoveRight: keep going past 1’s
        table.insert((State::MoveRight, '1'), (State::MoveRight, '1', Direction::Right));
        table.insert((State::MoveRight, '_'), (State::WriteOne, '_', Direction::Stay));
        // WriteOne: overwrite blank with '1' and halt
        table.insert((State::WriteOne, '_'), (State::Halt, '1', Direction::Stay));

        TuringMachine {
            tape,
            head:  0,
            state: State::Start,
            table,
        }
    }

    fn step(&mut self) {
        let symbol = *self.tape.get(&self.head).unwrap_or(&'_');
        if let Some(&(new_state, write_sym, dir)) = self.table.get(&(self.state, symbol)) {
            // write
            self.tape.insert(self.head, write_sym);
            // move
            match dir {
                Direction::Left  => self.head -= 1,
                Direction::Right => self.head += 1,
                Direction::Stay  => {}
            }
            // update state
            self.state = new_state;
        } else {
            // no matching rule → implicitly halt
            self.state = State::Halt;
        }
    }

    fn run(&mut self) {
        while self.state != State::Halt {
            self.step();
        }
    }

    fn contents(&self) -> String {
        // find occupied cells and return a string snapshot
        let min = *self.tape.keys().min().unwrap_or(&0);
        let max = *self.tape.keys().max().unwrap_or(&0);
        (min..=max)
            .map(|i| *self.tape.get(&i).unwrap_or(&'_'))
            .collect()
    }
}

fn main() {
    let mut tm = TuringMachine::new("111");  // input: 3 ones
    tm.run();
    println!("Resulting tape: {}", tm.contents()); // prints 1111
}
```

**Key parts:**

* A **tape** as a (conceptually infinite) map from positions to symbols (`'1'` or blank `‘_’`).
* A **head** index that reads/writes and moves.
* A **state** that picks which transition rule to apply.
* A **transition table** mapping `(state, symbol)` → `(new_state, write_symbol, move_dir)`.
* A simple `step()` loop and a `run()` until we hit `Halt`.

---

### 3. Lessons for Computation & Algorithm Design

1. **Algorithms = State + Memory + Rules.** Even this tiny Rust example shows how any algorithm can be broken into:

   * A finite set of **states** (the “instruction pointer”),
   * A “memory” tape you can read/write, and
   * A finite **rule table**.
     Every high-level program you write in Python or Rust ultimately compiles down to something very much like this.

2. **Decidability.** By playing with TMs, you see there’s no way to write a transition table that decides—for every possible other TM and input—whether it halts. That concrete exercise drives home the theoretical limits: some problems simply aren’t computable.

3. **Complexity taking shape.** If you count how many `step()` calls your TM makes on different input lengths, you get a primitive “running time.” Suddenly you’re asking: “Can I make a different table that does fewer steps?” …and voilà, complexity theory begins.

4. **Universality & interpreters.** A “universal” Turing machine is just a bigger transition table that can read the encoding of *any* other TM and simulate it. This is the conceptual ancestor of interpreters and virtual machines.

By building even a toy TM in Rust—and watching “1 → 2 → 3 → … → 4” get extended—you gain an intimate feel for what an algorithm really is, where its power comes from, and precisely where and why there are hard boundaries to what can be computed.
